## 1. Introduction

### 1.1 Purpose
The purpose of this document is to outline the design, functionality, and implementation of a Python-based port scanner. This software is developed to scan a range of ports on a target host and determine whether the ports are open or closed. The scanner supports error handling, logging, and rate-limiting to ensure a controlled and informative scanning process.

### 1.2 Scope
This software allows users to scan a range of ports on a target IP address or domain. It establishes network connections to each port to determine their status (open/closed) and logs the results. The software is designed for both local and remote scanning, with the flexibility to specify port ranges and implement error handling for invalid input or network issues.

### 1.3 Definitions, Acronyms, and Abbreviations
1. **Port Scanner**: A software application that checks if ports on a target machine are open or closed.
2. **Socket**: A network communication endpoint that allows the sending and receiving of data between devices.
3. **TCP**: Transmission Control Protocol, used for sending and receiving data between devices.
4. ? **TCP SYN Scan**: A method to determine whether a port is open by sending a SYN packet and waiting for a response.
5. **ICMP**: Internet Control Message Protocol, used for diagnostics like pinging devices.
6. **ARP**: Address Resolution Protocol, used to resolve an IP address to a MAC address in local networks.
7. **VM**: 2 Virtual Machines, used for remote host testing in a controlled environment.
8. **Rate Limiting**: A technique used to control the rate of requests to avoid overloading the network.
9. **Logging**: Recording events or messages for tracking program behavior and errors.

### 1.4 References
- Python Documentation: https://docs.python.org/3/
- Python Socket Library: https://docs.python.org/3/library/socket.html
- ChatGPT
- YouTube
  
## 2. System Overview

### 2.1 System Functionality
The port scanner works by taking a target host (IP address or domain) and a range of ports as input. It attempts to establish a connection to each port within the specified range. If the connection is successful, the port is considered open; otherwise, it is closed. The results are logged to a file (port_scanner.log) for further analysis.
 
The system is designed to:

-Handle errors gracefully (e.g., invalid hostnames or connection issues).
-Log both successful scans and errors.
-Rate-limit the scanning process to avoid excessive network usage.
  
### 2.2 Target Environment
1. **Localhost Testing**:
   - The scanner will first be tested on the local machine using the loopback address 127.0.0.1.
   - The scanner will be run on a local machine to scan localhost or other reachable hosts in the network.
3. **Virtual Machine Testing**: The scanner will be tested on two virtual machines with IP addresses in the 192.168.100.0/24 subnet. These machines will simulate a real network environment. 

## 3. Planning

## 3.1 Libraries Required
**socket**: The scanner can be used to scan remote hosts that the user has permission to scan.
**logging**: Used to log information and errors during the scanning process.
**datetime**: Used to track the start and end time of the scanning process.
**time**: Introduces a delay between scans to avoid overloading the network.

### 3.2 Protocols Used
- **TCP SYN Scan**: Sends a SYN (synchronize) packet to a target port and waits for a response. If the target responds with a SYN-ACK, the port is considered open.
- **ARP**: Address Resolution Protocol is essential in resolving IP addresses to MAC addresses, helping establish connections on the same local network.
- **ICMP**: This protocol is often used for diagnostic tools like ping and helps ensure the target machine is reachable.

### 3.3 Design Overview
**Input**: The user provides a target host (IP address or domain), a start port, and an end port. The program validates the inputs and proceeds with the scan.
**Port Scanning**: The program uses the socket library to attempt a connection on each port. Open ports are logged and returned as a list.
**Error Handling**: If the target host cannot be resolved or if there are network issues, the program logs the error and exits gracefully.
**Logging**: The scanning process and results are logged to a file (port_scanner.log).

## 4. Issues/Constraints

### 4.1 Ethical Considerations
**Authorization**: This port scanner should only be used on networks and hosts where the user has explicit permission to conduct scans. Unauthorized port scanning may be illegal and lead to legal consequences.

**Controlled Environment**: Testing will be restricted to localhost and virtual machines under the user's control to avoid unauthorized access or detection by intrusion detection systems (IDS).

### 4.2 Resource Constraints
**Rate Limiting**: The scanner introduces a delay between scans (default 0.5 seconds) to prevent excessive network load and ensure ethical usage of network resources.
**Resource Usage**: Large port ranges can increase scan time and resource consumption. The system is designed to mitigate this by using timeouts and rate limiting.
**Network Traffic**: Scanning multiple ports across various IP addresses can generate significant traffic, which could be detected as malicious activity by firewalls or IDS.


## 5. Coding Considerations

### 5.1 Input Validation
**IP Address Validation**: The system should validate that the provided IP address is valid and reachable. Invalid IP addresses can cause the scanner to fail.

**Port Range Validation**: The system should ensure that the user provides a valid port range, where the start port is less than or equal to the end port, and both ports are within the valid range (0-65535).

### 5.2 Error Handling
The system should handle various exceptions that might occur during scanning:
1. **Timeouts**: If a port does not respond within a specified time, it should be marked as closed, and the scanner should proceed without crashing.
2. **Invalid Inputs**: The system should prompt users with appropriate error messages if the IP address or port range is invalid.
3. **Network Issues**: In case of network disconnection or other unexpected issues, the system should safely handle the failure and exit gracefully.
   
### 5.3 Performance
**Connection Timeout**: To prevent the system from hanging on unresponsive ports, each connection attempt should have a short timeout (e.g., 0.1 seconds).
**Port Range Efficiency**: Efficient looping should be used to scan the ports within the provided range.

## 6. System Architecture

### 6.1 Functions and Components
**scan_ports(host, start_port, end_port)**: This function is responsible for scanning the ports between the specified start and end ports on the target IP address (host). It uses the socket library to create a connection to each port and determine if the port is open.



**scan_port(host, port)**: This function takes the host and port as input and attempts to establish a TCP connection to the port. It returns True if the port is open and False if the port is closed. If an error occurs, the function logs the error and returns None.

```python

def scan_port(host, port):
    """Scans a specific port on the given host.
    
    Parameters:
    host -- IP address or domain of the target host.
    port -- Port number to scan.
    
    Returns:
    True if the port is open, False if the port is closed, and None if an error occurs.
    """
    try:
        # Create a new socket for each port scan.
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Set a timeout to avoid hanging on unresponsive ports.
            result = s.connect_ex((host, port))  # Attempt to connect to the port.
            if result == 0:
                return True  # The port is open.
            else:
                return False  # The port is closed.
    except socket.gaierror:
        logging.error(f"Hostname could not be resolved: {host}")  # Log error if hostname cannot be resolved.
        return None
    except socket.error:
        logging.error(f"Couldn't connect to server: {host}")  # Log error if connection to the server fails.
        return None
```

**port_scanner(host, start_port, end_port, rate_limit=0.5)**: This function scans a range of ports on the specified host. It performs input validation to ensure valid port numbers and logs the results. A delay between scans (rate limiting) is implemented to prevent overloading the network.

```python

def port_scanner(host, start_port, end_port, rate_limit=0.5):
    """Scans a range of ports on the given host.
    
    Parameters:
    host -- IP address or domain of the target host.
    start_port -- Starting port number for the scan.
    end_port -- Ending port number for the scan.
    rate_limit -- Delay between scans (default is 0.5 seconds).
    
    Returns:
    A list of open ports.
    """
    open_ports = []  # List to store open ports.
    logging.info(f"Starting scan on host: {host} from port {start_port} to {end_port}")
    print(f"Scanning {host} from port {start_port} to {end_port}...")

    # Validate port range.
    if not (0 <= start_port <= 65535) or not (0 <= end_port <= 65535):
        print("Invalid port range. Ports must be between 0 and 65535.")
        return
    
    if start_port > end_port:
        print("Invalid range. Start port should be lower than end port.")
        return 

    # Iterate through the range of ports and scan each one.
    for port in range(start_port, end_port + 1):
        if scan_port(host, port):  # Call scan_port for each port.
            print(f"Port {port} is open")  # If open, print the port number.
            open_ports.append(port)  # Add open port to the list.
        else:
            print(f"Port {port} is closed")  # If closed, print the port number.
        time.sleep(rate_limit)  # Introduce delay to prevent overloading.

    logging.info(f"Scan complete. Open ports: {open_ports}")  # Log the results.
    return open_ports  # Return the list of open ports.
```

**Main Execution Block**: The main block handles user input, including host and port range validation, and calls the port_scanner function. The results are printed and logged.

```python
if __name__ == "__main__":
    target_host = input("Enter the host to scan:")  # Input target host.

    try:
        # Validate the hostname or IP address.
        socket.gethostbyname(target_host)
    except socket.gaierror:
        print("Invalid host. Please enter a valid IP address or domain.")  # Error message for invalid host.
        exit(1)

    try:
        # Input and validate port numbers.
        start_port = int(input("Enter the start port: "))
        end_port = int(input("Enter the end port: "))
    except ValueError:
        print("Port numbers must be integers.")  # Error message for invalid port numbers.
        exit(1)

    # Record the start time of the scan.
    start_time = datetime.now()
    
    # Call the port_scanner function and get open ports.
    open_ports = port_scanner(target_host, start_port, end_port, rate_limit=0.5)
    
    # Record the end time of the scan.
    end_time = datetime.now()

    # Print the results and scan duration.
    print(f"\nScanning completed in {end_time - start_time}. Open ports: {open_ports}")
    logging.info(f"Scan duration:  {end_time - start_time}")  # Log the scan duration.
```

### 6.2 Workflow
- The user inputs the target IP address and port range.
- The system validates the IP address and port range.
- The system loops through the ports in the specified range and attempts a connection.
- Each port's status is printed as either "open" or "closed."
- If an error occurs (e.g., timeout, invalid IP), the system handles it gracefully and continues scanning the remaining ports.

### 6.3 System Setup
**Localhost**: The initial test will be conducted on 127.0.0.1, scanning ports in the range 500-1024.
**VM Testing**: The system will then be tested in a virtual environment on a remote host with an IP in the 192.168.100.0/24 subnet.

## 7. Testing

### 7.1 Test Environment
**Localhost**: The scanner will be tested on 127.0.0.1 to ensure it can detect open ports on the local machine.
**Remote VM Testing**: Two virtual machines will be set up in the 192.168.100.0/24 subnet. The scanner will be tested on one VM scanning the other to ensure that remote scanning is functional.

### 7.2 Test Cases
**Localhost Scan**: Scan the localhost IP (127.0.0.1) for ports in the range 500-1024. Verify that open ports are accurately detected.
**Remote Scan**: Scan the remote host within the VM subnet for open ports in the same range. Ensure that the system correctly identifies open and closed ports on the remote machine.

## 8. Ethical Considerations
**Limited Testing**: Scanning is restricted to authorized environments, such as the localhost and VMs.
**Detectability**: Systems with intrusion detection systems (IDS) can detect port scanning. The system should only be used in an environment where this detection is not problematic.
**Compliance**: Ensure that all testing is done in compliance with legal and ethical guidelines. Unauthorized scanning can be classified as hacking and should be avoided.

## 9. Enhancements

### 9.1 Security Measures
Rate Limiting: Implementing a delay between port scans to prevent excessive scanning and reduce the risk of detection.
Logging: Adding a logging mechanism to store the results of the scan (e.g., which ports are open or closed) along with timestamps.

### 9.2 Secure Coding
Review the code for vulnerabilities that could allow input validation attacks (e.g., malicious IP addresses) or unhandled exceptions.

## 10. Properly Documented Code
The code will be well-documented with comments explaining each function and line of code.

```python
import socket  # Imports the socket library to create network connections.
import logging  # Imports the logging library to handle event and error logging.
from datetime import datetime  # Imports datetime to work with dates and times.
import time  # Imports time to introduce delays during execution.

# Setup logging configuration for saving logs into 'port_scanner.log' file.
logging.basicConfig(filename='port_scanner.log', level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def scan_port(host, port):
    """Function to scan a specific port on the given host.
    
    Parameters:
    host -- IP address or domain of the target host.
    port -- Port number to scan.
    
    Returns:
    True -- if the port is open.
    False -- if the port is closed.
    None -- in case of an error.
    """
    try:
        # Create a new socket for each port scan.
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Set a timeout to avoid hanging indefinitely on slow or unresponsive ports.
            result = s.connect_ex((host, port))  # Attempts to connect to the port.
            if result == 0:
                return True  # If the connection is successful, the port is open.
            else:
                return False  # If unable to connect, the port is closed.
    except socket.gaierror:
        # Log error if the hostname could not be resolved.
        logging.error(f"Hostname could not be resolved: {host}")
        print(f"Hostname could not be resolved: {host}")
        return None
    except socket.error:
        # Log error if unable to connect to the server.
        logging.error(f"Couldn't connect to server: {host}")
        print(f"Couldn't connect to server: {host}")
        return None

def port_scanner(host, start_port, end_port, rate_limit=0.5):
    """Function to scan a range of ports on the given host.
    
    Parameters:
    host -- IP address or domain of the target host.
    start_port -- Starting port number for the scan.
    end_port -- Ending port number for the scan.
    rate_limit -- Delay between port scans to avoid excessive scanning.
    
    Returns:
    List of open ports.
    """
    open_ports = []  # Initializes an empty list to store open ports.
    logging.info(f"Starting scan on host: {host} from port {start_port} to {end_port}")
    print(f"Scanning {host} from port {start_port} to {end_port}...")

    # Input validation to ensure port numbers are within the valid range.
    if not (0 <= start_port <= 65535) or not (0 <= end_port <= 65535):
        print("Invalid port range. Ports must be between 0 and 65535.")
        return
    
    if start_port > end_port:
        print("Invalid range. Start port should be lower than end port.")
        return 

    # Iterate through the specified port range and scan each port.
    for port in range(start_port, end_port + 1):
        if scan_port(host, port):  # Calls scan_port function to check each port.
            print(f"Port {port} is open")  # Print message if the port is open.
            open_ports.append(port)  # Adds the open port to the list.
        else:
            print(f"Port {port} is closed")  # Print message if the port is closed.
        time.sleep(rate_limit)  # Introduces a delay between scans to prevent rapid scanning.

    logging.info(f"Scan complete. Open ports: {open_ports}")  # Log the list of open ports.
    return open_ports  # Returns the list of open ports.

# Main execution block.
if __name__ == "__main__":
    target_host = input("Enter the host to scan:")  # Input the host (IP address or domain) to scan.

    try:
        # Validate the entered host (IP address or domain name).
        socket.gethostbyname(target_host)
    except socket.gaierror:
        print("Invalid host. Please enter a valid IP address or domain.")  # Print error message if the host is invalid.
        exit(1)

    try:
        # Input the start and end ports with integer validation.
        start_port = int(input("Enter the start port: "))
        end_port = int(input("Enter the end port: "))
    except ValueError:
        print("Port numbers must be integers.")  # Print error message if port numbers are not integers.
        exit(1)

    start_time = datetime.now()  # Record the start time of the scan.
    open_ports = port_scanner(target_host, start_port, end_port, rate_limit=0.5)  # Call the port scanning function.
    end_time = datetime.now()  # Record the end time of the scan.

    # Print the results of the scan and the time it took to complete.
    print(f"\nScanning completed in {end_time - start_time}. Open ports: {open_ports}")
    logging.info(f"Scan duration:  {end_time - start_time}")  # Log the duration of the scan.

```
## 11. Code explanation

1. **Imports:**

 -  **socket**: Allows working with network sockets, enabling port scanning.
 -  **logging**: Logs events and errors into a file for tracking.
 -  **datetime**: Handles time and date, used to calculate the duration of the scanning process.
 -  **time**: Adds delays between port scans.

2. **Logging setup:**

Logs events and errors into the file **port_scanner.log** with timestamps and severity levels (e.g., INFO, ERROR).

3. **scan_port function:**

-This function attempts to connect to a given port on the specified host.
-If successful, it returns True (port is open).
-If the connection fails, it returns False (port is closed).
-In case of errors (e.g., invalid hostname or connection issue), it logs the error and returns None.

4. **port_scanner function:**

-This function scans a range of ports on the specified host.
-It performs input validation to ensure the port numbers are within the correct range (0 to 65535).
-It calls the scan_port function for each port in the range, records open ports, and logs them.
-A delay (rate_limit) is introduced between port scans to avoid overwhelming the network.

5. **Main execution block:**

-Asks the user to input the host and port range.
-Validates the host format (IP address or domain).
-If valid, it starts the port scanning process, logs the results, and displays the total time taken for scanning.

## 12. Conclusion
This SDD outlines the design and functionality of a Python-based port scanner. The system is designed to scan ports efficiently and safely, with built-in error handling and ethical considerations. The project also includes potential enhancements such as rate limiting and logging for better performance and security. Testing will be conducted in a controlled environment with VMs to ensure compliance with ethical standards.
