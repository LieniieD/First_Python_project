## 1. Introduction
This document outlines the design of a Python-based port scanner, a tool used to check which ports on a target machine are open. The scanner will support basic functionalities such as scanning a range of ports, error handling, rate limiting, and logging results. It will also consider ethical implications, detection mechanisms, and potential enhancements like rate limiting and security best practices.

## 2. Objective
The main goal is to develop a Python port scanner that can scan a host machine to determine which ports are open. The scanner should handle errors, log results, implement rate limiting, and comply with ethical guidelines for network scanning.

## 3. Planning
### Key Steps:
1. Learn required Python libraries: ```socket```, ```logging```, and ```time```.
2. Understand ARP and ICMP protocols and how TCP SYN scan identifies open ports.
3. Define the IP range within a local subnet using VMs for remote host testing.
4. Implement input validation and error handling for safe execution.
5. Test the scanner on both local and remote hosts within a subnet.
6. Document software design, testing, ethical considerations, and potential enhancements.
   
## 4. System Requirements
#### Python Version: 3.x
#### Libraries:
1. **socket**: Used for creating network connections.
2. **logging**: Used for recording scan results and errors.
3. **time**: Used for implementing rate limiting.
#### VM's

## 5. Design Overview
The port scanner is designed to perform the following:

1. **Input Validation**: Ensures user inputs for the host and port range are valid.
2. **Connection**: Uses the ```socket``` library to connect to each port and check its status (open or closed).
3. **Rate Limiting**: Controls the scan speed to avoid network congestion or triggering security alerts.
4. **Logging**: Stores the results and errors encountered during scanning into a log file for later review.
   
## 6. Code Structure
```scan_port()```: This function attempts to connect to a specified port on the host machine and returns whether the port is open.
```port_scanner()```: This function manages scanning a range of ports, validates input, and logs the results. It also implements rate limiting to prevent scanning too quickly.
**Main execution**: The main block prompts the user for input, including the host, start port, and end port, and then initiates the scan.

## 7. Issues/Constraints
1. **Host Validation**: The program must handle invalid host names or unreachable hosts.
2. **Port Range Validation**: Port numbers must be between 0 and 65535, and the start port should not exceed the end port.
3. **Rate Limiting**: Excessive scanning can trigger security alarms, so a delay between scans is essential.
   
## 8. Ethical Considerations
Port scanning can be seen as intrusive. Ethical use of this tool involves:
**Permission**: Only scan networks and devices you own or have explicit permission to scan.
**Limited Testing**: Perform scans in a controlled environment, like a local network or virtual machines, to avoid violating network policies.

## 9. Enhancements
**Rate Limiting**: Introduced to control scanning frequency.
**Logging**: Results and errors are stored in a log file.
**Security Enhancements**: Reviewing the code for vulnerabilities and following best practices for secure programming.

## 10. Coding Considerations
The code must:

- Handle exceptions like unreachable hosts, invalid IP addresses, and connection failures.
- Include meaningful log messages to help with debugging and reviewing results.
- Follow Python best practices for security and efficiency.
  
## 11. Testing
**Local Testing**: Test the scanner on the localhost (127.0.0.1) to ensure basic functionality.
**Remote Testing**: Test on a VM with a specific subnet to verify network functionality.
**Error Handling**: Verify the program handles invalid inputs and network errors gracefully.

## 12. Detection of Port Scanning
Port scans can be detected by monitoring unusual network traffic patterns. Intrusion detection systems (IDS) can log and alert users when multiple ports on a machine are being probed.

## 13. Conclusion
The Python port scanner provides a basic but functional tool for scanning open ports. By implementing rate limiting, logging, and error handling, it adheres to security and ethical guidelines while offering room for enhancements.

```python

import socket
import logging
from datetime import datetime
import time

# Налаштовуємо логування (logging) для запису в файл 'port_scanner.log'
# Установлюємо рівень INFO і формат повідомлень, що включає час, рівень і повідомлення
logging.basicConfig(filename='port_scanner.log', level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

# Функція для сканування одного порту на цільовому хості
def scan_port(host, port):
    try:
        # Створюємо новий сокет для кожного порту
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(1)  # Установлюємо тайм-аут для уникнення зависання програми
            result = s.connect_ex((host, port))  # Повертає 0, якщо підключення вдалося (порт відкритий)
            if result == 0:
                print(f"[DEBUG] Port {port} on {host} is open")  # Виводимо повідомлення, що порт відкритий
                return True  # Повертаємо True, якщо порт відкритий
            else:
                print(f"[DEBUG] Port {port} on {host} is closed with result {result}")
                return False  # Повертаємо False, якщо порт закритий
    except Exception as e:
        # Виводимо повідомлення у разі загальної помилки
        print(f"[DEBUG] Error scanning port {port}: {str(e)}")
    except socket.gaierror:
        # Обробляємо помилку при невірному імені хоста
        logging.error(f"Hostname could not be resolved: {host}")
        print(f"Hostname could not be resolved: {host}")
        return None
    except socket.error:
        # Обробляємо помилку при неможливості підключення до хоста
        logging.error(f"Couldn't connect to server: {host}")
        print(f"Couldn't connect to server: {host}")
        return None

# Функція для сканування діапазону портів на вказаному хості
def port_scanner(host, start_port, end_port, rate_limit=0.5):
    open_ports = []  # Список для збереження відкритих портів
    logging.info(f"Starting scan on host: {host} from port {start_port} to {end_port}")
    print(f"Scanning {host} from port {start_port} to {end_port}...")
    
    # Валідація введених значень портів
    if not (0 <= start_port <= 65535) or not (0 <= end_port <= 65535):
        print("Invalid port range. Ports must be between 0 and 65535.")
        return

    if start_port > end_port:
        print("Invalid range. Start port must be less than or equal to end port.")
        return

    # Проходимо по кожному порту у вказаному діапазоні
    for port in range(start_port, end_port + 1):
        if scan_port(host, port):  # Скануємо кожен порт
            print(f"Port {port} is open")  # Виводимо повідомлення, якщо порт відкритий
            open_ports.append(port)  # Додаємо відкритий порт до списку
        else:
            print(f"Port {port} is closed")  # Виводимо повідомлення, якщо порт закритий
        time.sleep(rate_limit)  # Обмеження швидкості для уникнення надмірного сканування

    logging.info(f"Scan complete. Open ports: {open_ports}")  # Записуємо результати сканування у лог
    return open_ports  # Повертаємо список відкритих портів

# Основна частина програми
if __name__ == "__main__":
    # Запитуємо у користувача IP-адресу або ім'я хоста для сканування
    target_host = input("Enter the host to scan: ")
    
    try:
        # Валідація формату IP-адреси або імені хоста
        socket.gethostbyname(target_host)
    except socket.gaierror:
        # Виводимо помилку, якщо хост недійсний
        print("Invalid host. Please enter a valid IP address or domain.")
        exit(1)
    
    try:
        # Запитуємо у користувача початковий та кінцевий порти для сканування
        start_port = int(input("Enter the start port: "))
        end_port = int(input("Enter the end port: "))
    except ValueError:
        # Виводимо помилку, якщо порти введені не як цілі числа
        print("Port numbers must be integers.")
        exit(1)

    # Визначаємо час початку сканування
    start_time = datetime.now()
    # Виконуємо сканування портів на вказаному хості у зазначеному діапазоні
    open_ports = port_scanner(target_host, start_port, end_port, rate_limit=0.5)
    # Визначаємо час завершення сканування
    end_time = datetime.now()

    # Виводимо підсумки сканування, скільки часу тривало і які порти відкриті
    print(f"\nScanning completed in {end_time - start_time}. Open ports: {open_ports}")
    logging.info(f"Scan duration: {end_time - start_time}")  # Записуємо тривалість сканування у лог

```
